On our machines, the output of the malloc call is not always the same. We wrote a program that keeps trying to allocate memory one byte bigger than the previously succesful malloc call. However, after running this program for a while, the OS kills the program, because it is running out of RAM and swap space on the machine. How far this can go depends on how much RAM or swap is already in use by other programs.

Changing malloc() to calloc() would yield in earlier failure, as calloc sets the allocated memory buffers to zero. This ensures that the pointer to the memory is valid as the actual memory is availabe. Some operating systems are optimistic when mallocing, and will give back pointers to memory blocks that may be in use at the moment that the program actually needs to write something in there. Because calloc is initializing the memory, the program is sure that the memory is actually available.
